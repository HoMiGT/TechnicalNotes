# 1. 前言
> 1、 BJ设计C++就是为了回答这样一个问题：
> * 如何直接操作硬件同时又支持高效、高级的抽象？
>   
> 2、 俩个方面的关注：
> * 语言结构到硬件设备的直接映射
> * 零开销抽象
>
> ```
> 1. 零开销的解释：
> 你不用的东西，你就不需要付出代价;
> 你使用的东西，你手工写代码也不会更好。
>
> 2. 抽象的解释：
> 在代码中体现出函数、类、模板、概念和别名
> ```
> 3、 看待C++的一种方式，看成几十年来三种相互矛盾要求的结果
> * 让语言更简单！
> * 立即添加这两个必要特性！！
> * 不要搞砸我的(任何)代码！！！
>
> 4、 关于理性思考C++的成长，设计规则，一小部分：
> ```
> * 不要陷入对完美的徒劳追求。
> * 始终提供过渡路径。
> * 说出你的意图(即，能够直接表达高层次的思路)。
> ```
# 2. C++11
> 1、 C++依赖静态类型安全
> ```
> * 明确意图
>   * 帮助程序员直接表达想法
>   * 帮助编译器捕获更多错误
> * 帮助编译器生成更好的代码
> ```
> 2、 C++11与类型直接相关的改进
> * 对线程和锁的类型安全接口——避免POSIX和Windows在并发代码中对void**及宏的依赖
> * 范围for——避免错误地指定范围
> * 移动语义——解决指针的过度使用问题
> * 资源管理指针(unique_ptr和shared_ptr)
> * 统一初始化——让初始化更通用，更一致，更安全
> * constexpr——消除多处(无类型和无作用域的)宏的使用
> * 用户定义的字面量——让用户定义类型更像内建类型
> * enum class——消除一些涉及整数常量的弱类型做法
> * std::array——避免内建数组不安全地"退化"成指针
# 3. C++14:完成C++11
> 1、 C++14特性集
> * 二进制字面量
> * 数字分隔符——为了可读性
> * 变量模版——参数化的常量和变量
> * 函数返回类型推导
> * 泛型lambda表达式
> * constexpr函数中的局部变量
> * 移动捕获
> * 按类型访问元组
> * 标准库中的用户定义字面量
# 4. 概念
> * 概念——用于指定对模板参数要求的编译期谓语
> * 根据使用模式来指定原始约束——以处理重载和隐式类型转换
> * 多参数概念
> * 类型和值概念
> * 模板的“类型的类型”简写记法，使泛型编程更接近于“普通编程”
> * auto作为函数参数和返回值中约束最少得类型
> * 同一函数调用——减少泛型编程与面向对象编程之间的风格差异问题
# 5. C++17
> 

